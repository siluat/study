# Chapter 8 서버에 정보 보내기

## 이론 학습

### 폼(Form)의 동작 방식

- 사용자가 폼을 submit하면 브라우저는 폼 필드에서 이름-값 쌍을 수집하여 HTTP POST 요청에 넣어 폼의 action 속성에 정의된 URL로 전송한다.
- 폼을 구현하는 것은 HTTP POST를 구현하는 것부터 input 엘리먼트를 그리는 새 레이아웃 객체 말고도 버튼 클릭 처리까지 브라우저의 많은 부분을 확장해야 한다.

## 실습

- `<input>` 태그를 위한 입력창과 `<button>` 태그를 위한 버튼 구현을 위한 InputLayout 클래스 구현
  - 새로운 레이아웃 객체를 추가하는 것은 브라우저를 확장하는 일반적인 방법 중 하나이다.
  - TextLayout를 복제하고 필요한 부분을 변경하여 구현한다.
  - TextLayout가 달리 word 인수가 필요 없다.
  - 고정된 너비를 사용한다. 실습 브라우저에서는 해당 너비를 200px로 정의한다.
  - input 엘리먼트와 button 엘리먼트는 사용자가 식별할 수 있도록 가시성을 고려해야 한다. 해당 요소에 대한 실습 브라우저만의 기본 스타일을 정의한다.
  - paint 메서드에 기본 스타일로 정의한 배경색을 그리기 위한 커맨트 생성을 추가한다.
  - paint 메서드에 텍스트 콘텐츠를 그리기 위한 커맨트 생성을 추가한다.
    - input 태그의 경우 value 속성값을 텍스트 콘텐츠로 사용한다.
    - button 태그의 경우 자식 텍스트 노드의 텍스트 값을 사용한다. button 태그의 경우 자식 요소로 복잡한 HTML이 존재할 수도 있다. 실습 브라우저에서는 하나의 텍스트 노드만 처리하고, 그 외에는 무시하도록 구현한다. 실제 브라우저는 inline-block 디스플레이 모드를 지원한다.
- BlockLayout에서 InputLayout 생성을 처리
  - InputLayout 객체를 초기화하는 input 메서드를 추가한다.
    - input 메서드는 새로 추가할 InputLayout 객체의 너비를 기준으로 줄바꿈 필요 여부를 계산하고 필요에 따라 줄바꿈 메서드를 호출한다.
    - 폰트 스타일을 참조하여 현재 생성한 InputLayout 객체 다음 요소의 x 위치를 계산하여 현재 BlockLayout 객체의 cursor_x 필드값을 업데이트한다.
  - recurse 메서드에 input 및 button 태그 탐색시 input 메서드를 호출해서 InputLayout 객체를 추가한다.
  - 레이아웃 모드 메서드 변경
    - 지금까지의 구현에서는 자식노드가 없다면 레이아웃 모드를 블록 모드로 판단했다. 하지만 input 엘리먼트는 자식이 없지만 인라인 모드로 처리해야 한다. 해당 조건문을 추가하여 인라인 모드로 처리한다.
    - button 엘리먼트는 자식이 존재하지만 특별 취급이 필요하다.
      - 이런 요소가 어토믹(atomic) 인라인 레벨 박스의 예이다.
  - should_paint 메서드 추가
    - 블록 형제 노드가 있을 경우 input이나 button 엘리먼트는 때때로 내부에 InputLayout을 만드는 BlockLayout을 만든다. 이 경우 배경을 두 번 칠하는 문제가 있는데 이를 회피하기 위해 should_paint 메서드를 추가하여 해당 상황의 BlockLayout의 경우 배경색 그리기를 건너뛰게 처리한다.
    - 다른 레이아웃 객체에도 should_paint를 추가하고 해당 메서드는 True를 반환한다.
    - paint_tree 함수는 should_paint 메서드를 확인하여 해당 레이아웃 객체의 페인트 처리 여부를 결정한다.
- input 엘리먼트의 상호작용 구현
  - input을 클릭하면 콘텐츠를 지우고 타이핑할 수 있게 구현한다.
  - Tab 객체의 click 메서드에서 input 요소의 경우 해당 요소의 value 속성값을 빈 문자열로 초기화한다.
  - 실제 화면에서도 값을 지우려면 레이아웃 트리를 업데이트하고 디스플레이 리스트도 업데이트해야 한다. 지금까지의 구현으로는 load 메서드에 전체 페이지 로드 과정이 포함되어 있어, 스타일링, 레이아웃, 페인팅 단계만 다시 처리할 수가 없다.(이 단계를 렌더링이라고 부른다) 렌더링만 분리해서 처리할 수 있도록 load 메서드의 일부를 render 메서드로 분리한다.
  - 사용자 입력을 처리하기 위해 포커스된 input 요소를 기억해야 한다. 포커스된 요소를 기억하기 위한 focus 필드를 Tab 클래스에 추가하고 input 클릭 이벤트 처리시 해당 요소를 focus 필드에 저장한다. 다른 엘리먼트를 클릭하면 포커스를 해제하기 위해 focus 필드를 None으로 초기화한다.
  - 현재 사용자 키 입력을 Browser 객체에서 처리하고 있으므로 Browser 객체도 focus 저장하고 있어야 한다. Tab으로 보내야한다는 것을 기억하기 위해 focus 필드에 'content'라는 값으로 저장한다.
  - 웹페이지 클릭시 Chrome 요소의 포커스를 해제해야 한다. 포커스 해제를 처리하는 blur 메서드를 Chrome 클래스에 추가하고 Browser 객체에서 클릭 이벤트 탐지시 해당 메서드를 호출한다.
  - Browser 객체는 키입력을 크롬 객체에 전달하고, 크롬 객체가 해당 키를 소비하지 않았고 웹 페이지 요소가 포커싱 되어 있다면 Tab 객체로 키 입력을 전달한다.
    - 이를 위해 Chrome 클래스의 keypress 메서드가 키 입력 소비 여부를 반환하도록 변경한다.
  - 키 입력으로 input 요소의 값이 변경되는 경우 화면을 다시 그릴 필요는 없이 디스플레이 리스트만 다시 생성한다. draw 메서드가 아닌 render를 호출한다.
  - 실습 구현과 같은 계층구조로 된 포커스 핸들링은 그래픽 위젯을 처리하는 데 중요하다. iframe을 사용하는 페이지의 경우 실제 브라우저에서는 포커스 트리가 깊게 생성될 수도 있다.
  - 포커스된 input 요소에 커서를 그리기 위해 Element 클래스에 포커스 여부를 저장하기 위한 is_focused 필드를 추가하고 각 클릭 이벤트에서 is_focused 값을 상황에 맞게 설정한다. InputLayout 클래스의 paint 메서드에서 is_focused 값을 확인하여 커서를 그리기 위한 커맨트를 추가한다.
- button 엘리먼트의 form submit 구현
  - Tab의 click 메서드에서 버튼 태그의 클릭 이벤트를 감지한다. 클릭 이벤트가 발생하면 부모 노드를 올라가며 form 엘리먼트를 찾는다.
  - 가장 가까운 부모 form 엘리먼트에 action 속성값이 존재한다면, 해당 form 엘리먼트의 모든 자식 노드를 탐색하여 input 엘리먼트를 찾는다.
  - submit 처리를 하는 submit_form 메서드를 Tab 클래스에 추가한다.
    - 모든 input 엘리먼트의 name 속성과 value 속성 값으로 폼 인코딩을 처리한다. 한 쌍은 name=value 형태로 만드로 각 쌍은 `&`로 연결한다.
    - action 속성값을 url로, 인코딩한 데이터를 body로 전달해서 load 메서드를 호출한다.
  - load 메서드에 payload 인수를 추가한다. load 메서드는 URL.request 호출시 payload를 전달한다.
  - URL 클래스의 request 메서드에 payload 인수를 추가한다.
    - payload가 존재하면 method를 POST로 설정하고 Content-Length 헤더를 추가한다. 또한 request 뒤에 payload를 추가한다.
