# Chapter 5 페이지 레이아웃

## 이론 학습

### 레이아웃 트리

> 레이아웃 트리는 웹 개발자가 접근할 수 없으므로 표준화되어 있지 않고 브라우저마다 구조가 다릅니다. 이름조차 일치하지 않습니다! 크롬에서는 레이아웃 트리(layout tree), 사파리는 렌더 트리(render tree), 파이어폭스는 프레임 트리(frame tree)라고 부릅니다.

- 웹 브라우저는 경계선, 배경 등 다양한 시각 효과를 처리하기 위해 레이아웃 트리를 만든다. 
- 지금까지의 실습 브라우저는 엘리먼트의 너비나 높이 같은 엘리먼트 자체에 대한 정보들을 계산하지 않는데 이러한 정보를 계산하여 레이아웃 트리에 포함한다.
- 레이아웃 트리의 노드들은 HTML 엘리먼트와 연결되어 있고 각각 크기와 위치를 갖는 레이아웃 오브젝트가 된다.
  - 대부분의 엘리먼트는 각각 하나의 레이아웃 객체를 가진다.
  - 예외도 있다. `<script>` 같은 엘리먼트는 레이아웃 객체를 생성하지 않고, `<li>` 엘리먼트들은 글머리 기호를 위한 레이아웃 객체를 더 갖는다.
- 레이아웃 트리는 HTML 트리를 순회하며 만든다.

### 레이아웃 모드

> CSS에서 레이아웃 모드는 display 프로퍼티로 설정합니다. inline이나 block과 같은 아주 오래된 CSS 레이아웃 모드는 부모 엘리먼트가 아닌 자식 엘리먼트에 설정되어 어나니머스 블록 박스와 같은 특수장치가 필요하곤 했습니다. inline-block, flex, grid와 같은 새로운 프로퍼티들은 부모 엘리먼트에 설정되어 이러한 종류의 오류를 피하고 있습니다.

## 실습

- Layout 클래스를 레이아웃 트리를 다룰 수 있는 구조로 확장한다.
  - Layout 생성자에서 레이아웃 처리를 별도 메서드로 분리한다. 생성자는 전달받은 노드만 저장한다.
  - 트리 구조를 위해 생성자에 자식 포인터, 부모 포인터, 이전 형제에 대한 포인터 처리를 추가한다. 형제에 대한 포인터는 나중에 크기와 위치를 계산하는 데 필요하다.
- 레이아웃 트리의 루트 역할을 할 레이아웃 객체 추가
  - Layout 객체 생성에 부모 및 형제 포인터 정보가 추가되면서 Browser 객체에서 직접 Layout 객체를 생성하기 어렵다. 루트 역할을 할 별도의 레이아웃 객체, DocumentLayout 객체를 추가한다.
  - DocumentLayout 객체의 layout 메서드는 자식 노드를 생성하고 자식 노드의 layout 메서드를 재귀 호출하는 역할을 한다.
- 기존 Layout 클래스의 이름을 BlockLayout으로 변경
  - DocumentLayout 클래스와의 모호함을 줄이기 위해 더 구체적인 이름으로 변경한다.
  - 궁극적으로 문단이나 헤딩 같은 텍스트 블록을 표현할 것이므로 BlockLayout이라는 이름을 사용한다.
- BlockLayout 클래스의 layout 메서드 확장
  - 텍스트나 `<b>` 같은 텍스트 관련 태그는 기존 `recurse`와 `flush` 메서드를 사용해서 처리한다.
  - `<p>`나 `<h1>` 같은 블록 태그는 새 BlockLayout 객체로 생성하고 자식 노드로 추가한다.
  - 위 두 가지 레이아웃 처리를 구분하기 위해 각각 `lnline`과 `block` 레이아웃 모드 구분을 추가한다.
    - 하나의 노드에 블록 자식과 텍스트 자식이 모두 포함되어 있는 경우는 오류 케이스로 4장의 암시적 태그와 같은 적절한 복구 매커니즘이 필요하다. 실습 브라우저에서는 일단 블록 모드를 사용하는 것으로 처리한다. 실제 브라우저의 이런 복구 메커니즘을 '어나니머스 블록 박스'라고 하며 훨씬 더 복잡하다.
- BlockLayout 객체의 크기와 위치 계산
  - 각 BlockLayout 객체마다 독립적으로 계산하기 위해 x, y, width, height 필드를 추가한다.
  - 페이지 상의 절대 위치를 계산하는 기존과는 다르게 해당 BlockLayout 객체의 x, y에 대한 상대 위치로 계산한다.
    - flush에서 디스플레이 리스트를 계산할 때도 상대 위치 계산을 위해 현재 x, y 위치를 더해야 한다.
    - 줄바꿈 처리도 절대적 수치인 페이지의 width가 아닌 해당 블록의 width값을 기준으로 처리한다.
  - 레이아웃 객체의 가로 위치는 부모의 왼쪽 가장자리에서 시작하여 부모 엘리먼트를 채운다.
  - 레이아웃 객체의 세로 위치는 이전 형제 노드 존재 여부에 따라 달라진다. 있다면 형제 객체 바로 뒤에서 시작하고, 없다면 부모 객체의 상단에서 시작한다.
  - 높이는 모든 자식을 포함할 수 있을 만큼 충분히 커야 하므로, 자식들의 높이를 합해서 계산한다.
    - 텍스트를 담고 있는 레이아웃 객체는 자식 블록이 없으므로 모든 텍스트를 포함할 만큼의 높이로 cursor_y 값을 사용한다.
  - 계산 가능 여부에 따라 너비는 부모 노드에서 자식으로 하향식 계산, 높이는 자식에서 부모 노드로 상향식 계산을 하게 된다.
- DocumentLayout 객체의 레이아웃 게산
  - 문서가 항상 같은 위치에서 시작하기 때문에 간단하게 상수로 처리할 수 있다.
- 재귀 페인팅 처리
  - 각 레이아웃 객체가 해당 객체의 디스플레이 리스트를 반환하도록 paint 함수를 추가한다.
- 배경 그리기 기능 추가
  - 지금까지의 디스플레이 리스트는 화면에 그릴 단어의 리스트였지만, 그리기 명령(command)의 리스트로 개념화할 수 있다. 텍스트와 배경을 그리는 명령을 각각 DrawText, DrawRect 클래스로 표현한다.
  - BlockLayout은 인라인 모드일 때 각 단어를 그리는 DrawText 명령을 디스플레이 리스트에 추가한다.
  - 배경 그리기 작동 확인을 위해 `<pre>` 태그에 한해 배경을 그리는 DrawRect 명령을 디스플레이 리스트에 추가한다.
  - Draw* 객체에는 각 그래픽 명령들을 draw하는 execute 메서드를 추가한다.
- Browser 객체의 draw 메서드 변경
  - 구체적인 그리기를 직접 수행하지 않고, Draw 객체의 execute 메서드를 실행해서 그리기를 실행한다.
  - 화면 밖의 요소는 그리기를 생략하도록 Draw 객체의 top과 bottom 속성을 참조한다.
- 스크롤 다운 제한
  - 레이아웃 트리를 통해 전체 페이지의 높이를 알 수 있게 되었다. 페이지의 끝을 넘어가는 것을 제한할 수 있다.
