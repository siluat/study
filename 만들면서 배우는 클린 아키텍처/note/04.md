# 04. 유스케이스 구현하기

## 도메인 모델 구현하기

- 한 계좌에서 다른 계좌로 송금하는 유스케이스를 구현하기 위해 입금과 출금을 할 수 있는 Account 엔티티를 만든다.
- 한 계좌에 대한 모든 활동(Activity)을 항상 메모리에 한꺼번에 올리는 것은 현명한 방법이 아니므로 ActivityWindow 값 객체에 지난 며칠 혹은 몇 주간의 범위에 해당하는 활동만 보유한다.

## 유스케이스 둘러보기

일반적인 유스케이스의 단계

1. 입력을 받는다
2. 비즈니스 규칙을 검증한다
3. 모델 상태를 조작한다
4. 출력을 반환한다

'송금하기(SendMoney)' 유스케이스 구현 예시

- 하나의 서비스가 하나의 유스케이스를 구현한다.
- 유스케이스는 인커밍 어댑터로부터 입력을 받는다.
- 서비스는 도메인 모델을 변경하고, 변경된 상태를 저장하기 위해 아웃고잉 포트를 호출한다.

## 입력 유효성 검증

- 입력 유효성 검증은 애플리케이션 계층의 책임으로 한다.
  - 그렇지 않을 경우 애플리케이션 계층 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있다.
- 입력 유효성 검증 책임의 위치로
  - 유스케이스 클래스는 도메인 로직에만 신경써야하므로 적합하지 않다.
  - 어댑터의 경우, 유스케이스는 하나 이상의 어댑터에서 호출되므로 각 어댑터에서 전부 구현해야 하므로 적합하지 않다. 실수 가능성이 높다.
  - 입력 모델이 적합하다. 더 정확히는 생성자 내에서 입력 유효성을 검증하는 것이다.
    - 검증에 실패하면 예외를 던져 객체 생성을 막는다.
    - 객체 생성이 성공했다면, 유효한 것이고 불변 필드만을 사용해 생성 이후에도 유효성을 보장할 수 있다.

## 생성자의 힘

입력 모델 `SendMoneyCommand`는 생성자에 많은 책임을 지우고 있어 빌더 패턴을 사용하는 것을 고려해볼 수 있지만, 생성자를 사용하는 것이 실수로부터 더 안전하다. 빌드 패턴을 사용했을 경우 새로운 필드를 추가하거나 기존 필드를 삭제할 때, 빌더를 사용하는 모든 곳을 수정해야 하기 때문이다. 실수로 누락해도 런타임에 오류가 발생하겠지만, 컴파일러가 경고해주지 못한다.

## 유스케이스마다 다른 입력 모델

여러 유스케이스에서 동일한 입력 모델을 재사용하고 싶을 수도 있지만, 그 경우 입력 모델의 특정 필드에 null을 허용해야 하는 경우가 생기기 쉽다. 유효성 검증 로직이 복잡해지거나, 책임이 다른 곳에 흩어지는 여지를 만들 수 있다.

각 유스케이스 전용 입력 모델 사용은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과가 발생하지 않게 한다. 다만 들어오는 데이터를 각 유스케이스에 해당하는 입력 모델에 매핑해야 하는 비용이 발생한다. 매핑 전략에 대해서는 8장에서 다룬다.

## 비즈니스 규칙 검증하기

- 입력 유효성 검증과 달리 비즈니스 규칙 검증은 유스케이스 로직의 일부다.
- 입력 유효성을 검증하는 것은 **구문상의(syntactical)** 유효성을 검증, 비즈니스 규칙을 검증하는 것은 유스케이스의 맥락 속에서 **의미적인(semantical)** 유효성을 검증하는 일이라고 할 수 있다.
- 입력 유효성 검증과 비즈니스 규칙 검증의 아주 실용적인 구분점은 도메인 모델의 현재 상태에 접근하는지 여부다.
  - 입력 유효성 검증은 도메인 모델의 상태에 접근하지 않는다. (예: 송금되는 금액은 0보다 커야 한다.)
  - 비즈니스 규칙 검증은 도메인 모델의 상태에 접근한다. (예: 출금 계좌는 초과 출금되어서는 안 된다.)
- 비즈니스 규칙 검증 위치로 가장 좋은 방법은 도메인 엔티티 안에 넣는 것이다. 여의치 않다면 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 해도 된다.
  - 비즈니스 로직과 가까운 거리에 규칙에 위치하는 것이, 위치를 정하거나 추론하기 쉽다.

## 풍부한 도메인 모델 vs. 빈약한 도메인 모델

- 풍부한 도메인 모델에서는 애플리케이션 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직이 구현된다. 반면 빈약한 도메인 모델에서는 엔티티는 상태를 표현하는 필드와 getter, setter 메서드만 포함하고 어떤 도메인 로직도 가지고 있지 않다.
- 빈약한 도메인 모델의 경우 도메인 로직이 유스케이스 클래스에 구현되어 '풍부함'이 엔티티 대신 유스케이스에 존재하게 된다.
- 필요에 맞는 스타일을 자유롭게 택해서 사용하면 된다.

## 유스케이스마다 다른 출력 모델

- 입력과 비슷하게 출력도 가능하면 각 유스케이스에 맞게 구체적일수록 좋다.
- 정답은 없다. 그러나 유스케이스를 가능한 한 구체적으로 유지하기 위해서는 계속 질문해야 한다. 만약 의심스럽다면 가능한 한 적게 반환하자.
- 유스케이스들 간 출력 모델을 공유하게 되면 강하게 결합된다. 공유 모델은 장기적으로 봤을 때 갖가지 이유로 점점 커지게 돼 있다. 모델을 분리해서 유지하는 것이 도움이 된다.
- 같은 이유로 도메인 엔티티를 출력 모델로 사용하고 싶은 유혹도 견뎌야 한다.

## 읽기 전용 유스케이스는 어떨까?

- 읽기 전용 작업은 유스케이스와 구분하여 쿼리 서비스로 구현할 수 있다.
- 쓰기가 가능한 유스케이스와 읽기 전용 쿼리를 코드 상에서 명확하게 구분할 수 있다는 장점이 있다.
