# 04. 유스케이스 구현하기

## 도메인 모델 구현하기

- 한 계좌에서 다른 계좌로 송금하는 유스케이스를 구현하기 위해 입금과 출금을 할 수 있는 Account 엔티티를 만든다.
- 한 계좌에 대한 모든 활동(Activity)을 항상 메모리에 한꺼번에 올리는 것은 현명한 방법이 아니므로 ActivityWindow 값 객체에 지난 며칠 혹은 몇 주간의 범위에 해당하는 활동만 보유한다.

## 유스케이스 둘러보기

일반적인 유스케이스의 단계

1. 입력을 받는다
2. 비즈니스 규칙을 검증한다
3. 모델 상태를 조작한다
4. 출력을 반환한다

'송금하기(SendMoney)' 유스케이스 구현 예시

- 하나의 서비스가 하나의 유스케이스를 구현한다.
- 유스케이스는 인커밍 어댑터로부터 입력을 받는다.
- 서비스는 도메인 모델을 변경하고, 변경된 상태를 저장하기 위해 아웃고잉 포트를 호출한다.

## 입력 유효성 검증

- 입력 유효성 검증은 애플리케이션 계층의 책임으로 한다.
  - 그렇지 않을 경우 애플리케이션 계층 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있다.
- 입력 유효성 검증 책임의 위치로
  - 유스케이스 클래스는 도메인 로직에만 신경써야하므로 적합하지 않다.
  - 어댑터의 경우, 유스케이스는 하나 이상의 어댑터에서 호출되므로 각 어댑터에서 전부 구현해야 하므로 적합하지 않다. 실수 가능성이 높다.
  - 입력 모델이 적합하다. 더 정확히는 생성자 내에서 입력 유효성을 검증하는 것이다.
    - 검증에 실패하면 예외를 던져 객체 생성을 막는다.
    - 객체 생성이 성공했다면, 유효한 것이고 불변 필드만을 사용해 생성 이후에도 유효성을 보장할 수 있다.

## 생성자의 힘

입력 모델 `SendMoneyCommand`는 생성자에 많은 책임을 지우고 있어 빌더 패턴을 사용하는 것을 고려해볼 수 있지만, 생성자를 사용하는 것이 실수로부터 더 안전하다. 빌드 패턴을 사용했을 경우 새로운 필드를 추가하거나 기존 필드를 삭제할 때, 빌더를 사용하는 모든 곳을 수정해야 하기 때문이다. 실수로 누락해도 런타임에 오류가 발생하겠지만, 컴파일러가 경고해주지 못한다.

## 유스케이스마다 다른 입력 모델

여러 유스케이스에서 동일한 입력 모델을 재사용하고 싶을 수도 있지만, 그 경우 입력 모델의 특정 필드에 null을 허용해야 하는 경우가 생기기 쉽다. 유효성 검증 로직이 복잡해지거나, 책임이 다른 곳에 흩어지는 여지를 만들 수 있다.

각 유스케이스 전용 입력 모델 사용은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과가 발생하지 않게 한다. 다만 들어오는 데이터를 각 유스케이스에 해당하는 입력 모델에 매핑해야 하는 비용이 발생한다. 매핑 전략에 대해서는 8장에서 다룬다.
