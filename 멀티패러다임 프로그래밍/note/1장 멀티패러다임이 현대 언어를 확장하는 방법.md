# 1장 멀티패러다임이 현대 언어를 확장하는 방법

## 1.1 객체지향 디자인 패턴의 반복자 패턴과 일급 함수

### 1.1.1 GoF의 반복자 패턴

컬렉션의 내부 구조를 노출하는 대신 next() 같은 public 메서드로 내부 요소에 접근 -> **컬렉션의 실제 구조와 상관없이 일관된 방식으로 순회 가능**

```ts
// Iterator 인터페이스 예시

interface IteratorYieldResult<T> {
  done?: false;
  value: T;
}

interface IteratorReturnResult {
  done: true;
  value?: undefined;
}

interface Iterator<T> {
  next(): IteratorYieldResult<T> | IteratorReturnResult;
}
```

### 1.1.2 ArrayLike로부터 Iterator 생성하기

next()를 실행한 만큼만 요소를 순회하고 next()를 실행하지 않으면 순회하지 않게 된다. -> **이러한 특성을 활용해 지연 평가를 구현할 수 있다.**

```ts
// ArrayLike로부터 Iterator를 생성하는 클래스 예시

class ArrayLikeIterator<T> implements Iterator<T> {
  private index = 0;
  constructor(private arrayLike: ArrayLike<T>) {}

  next(): IteratorResult<T> {
    if (this.index < this.arrayLike.length) {
      return {
        value: this.arrayLike[this.index++],
        done: false,
      };
    } else {
      return {
        value: undefined,
        done: true,
      };
    }
  }
}

const arrayLike: ArrayLike<number> = {
  0: 10,
  1: 20,
  2: 30,
  length: 3,
};

const iterator: Iterator<number> = new ArrayLikeIterator(arrayLike);

console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());

// array를 ArrayLikeIterator로 만들어 순회하기
const array: Array<string> = ['a', 'b', 'c'];
const iterator2: Iterator<string> = new ArrayLikeIterator(array);

console.log(iterator2.next());
console.log(iterator2.next());
console.log(iterator2.next());
console.log(iterator2.next());
```

### 1.1.3 ArrayLike를 역순으로 순회하는 이터레이터 만들기

**Array의 reverse() 메서드와 이터레이터의 비교**

- Array의 reverse() 메서드: 배열의 요소에 접근하기 전에 이미 요소들의 순서가 반전되어 있다.
- 이터레이터의 지연성을 이용한 reverse 함수: 배열을 실제로 뒤집지 않고도 역순으로 순회할 수 있다. -> **불필요한 연산과 메모리 사용량을 줄이며 필요한 시점에만 연산**

```ts
// Interator를 반환하는 reverse 함수 예시
function reverse<T>(arrayLike: ArrayLike<T>): Iterator<T> {
  let idx = arrayLike.length;
  return {
    next(): {
      if (idx === 0) {
        return { value: undefined, done: true };
      } else {
        return { value: arrayLike[--idx], done: false };
      }
    }
  };
}

const array = ['A', 'B'];
const reversed = reverse(array);
console.log(array);

console.log(reversed.next().value, reversed.next().value);
```

**지연 평가가 더 효율적인 상황**
- 배열의 크기에 비해 역순으로 순회할 요소의 개수가 적을 때
- 배열의 원본을 보존해야 할 때

### 1.1.4 지연 평가되는 map 함수

```ts
// Iterator<A>를 받아서 Iterator<B>를 반환하는 map 함수 예시
function map<A, B>(transform: (value: A) => B, iterator: Iterator<A>): Iterator<B> {
  return {
    next(): IteratorResult<B> {
      const { value, done } = iterator.next();
      return done
        ? { value, done };
        : { value: transform(value), done };
    }
  };
}

const array = ['A', 'B', 'C', 'D', 'E', 'F'];
const iterator = map(str => str.toLowerCase(), reverse(array));
console.log(iterator.next().value, iterator.next().value);
```

**반복자 패턴**은 지연 평가가 가능한 객체를 생성할 수 있게 해주고 **일급 함수**는 고차 함수를 정의할 수 있게 한다.
두 가지를 조합하면 map, filter, take, reduce 등 지연 평가를 활용하거나 지연 평가된 리스트를 다루는 함수를 구현할 수 있다.

## 1.2 명령형 프로그래밍으로 이터레이터를 만드는 제너레이터 함수

어떤 문제는 명령형 스타일로 해결하는 것이 더 효율적이면서도 직관적일 때가 있다.  
제너레이터는 객체지향, 함수형 패러다임과 명령형 스타일이 서로 협력할 수 있게 하는 중요한 기반을 제공한다.

### 1.2.1 제너레이터 기본 문법

```ts
// 간단한 genrerator 함수
function* generator() {
  yield 1;
  yield 2;
  yield 3;
}

const iter = generator();

console.log(iter.next()); // { value: 1, done: false }
console.log(iter.next()); // { value: 2, done: false }
console.log(iter.next()); // { value: 3, done: false }
console.log(iter.next()); // { value: undefined, done: true }
```

```ts
// 제너레이터의 일시 중지
function* generator() {
  yield 1;
  console.log('hi');
  yield 2;
  yield 3;
}

const iter = generator();

console.log(iter.next()); 
// { value: 1, done: false }
console.log(iter.next()); // hi <-- 이때 console.log('hi');가 실행됨
// { value: 2, done: false }
console.log(iter.next()); 
// { value: 3, done: false }
console.log(iter.next()); 
// { value: undefined, done: true }
```

```ts
// 제너레이터와 제어문
function* generator(condition: boolean) {
  yield 1;
  if (condition) {
    yield 2;
  }
  yield 3;
}

const iter1= generator(false);

console.log(iter1.next()); // { value: 1, done: false }
console.log(iter1.next()); // { value: 3, done: false }
console.log(iter1.next()); // { value: undefined, done: true }

const iter2 = generator(true);

console.log(iter2.next()); // { value: 1, done: false }
console.log(iter2.next()); // { value: 2, done: false }
console.log(iter2.next()); // { value: 3, done: false }
console.log(iter2.next()); // { value: undefined, done: true }
```

```ts
function* generator() {
  yield 1;
  yield* [2, 3];
  yield 4;
}

const iter = generator();

console.log(iter.next()); // { value: 1, done: false }
console.log(iter.next()); // { value: 2, done: false }
console.log(iter.next()); // { value: 3, done: false }
console.log(iter.next()); // { value: 4, done: false }
console.log(iter.next()); // { value: undefined, done: true }
```

```ts
// nuturals 제너레이터 함수
function* naturals() {
  let n = 1;
  while (true) {
    yield n++;
  }
}

const iter = naturals();

console.log(iter.next()); // { value: 1, done: false }
console.log(iter.next()); // { value: 2, done: false }
console.log(iter.next()); // { value: 3, done: false }
```

### 1.2.2 제너레이터로 작성한 reverse 함수

```ts
// 제너레이터로 작성한 reverse 함수 예시
function* reverse<T>(arrayLike: ArrayLike<T>): IterableIterator<T> {
  let idx = arrayLike.length;
  while (idx) {
    yield arrayLike[--idx];
  }
}

const array = ['A', 'B', 'C', 'D', 'E', 'F'];
const reversed = reverse(array);

console.log(reversed.next().value); // F
console.log(reversed.next().value); // E
console.log(reversed.next().value); // D
```
